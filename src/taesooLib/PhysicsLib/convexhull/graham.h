#ifndef GRAHAMSCAN_H_
#define GRAHAMSCAN_H_
class GrahamScan
{
public :
    GrahamScan( size_t n, double xmin, double xmax, double ymin, double ymax );

	GrahamScan();
	void add_point(std::pair<double, double> const& point);

    //
    // The initial array of points is stored in vectgor raw_points. I first
    // sort it, which gives me the far left and far right points of the hull.
    // These are special values, and they are stored off separately in the left
    // and right members.
    //
    // I then go through the list of raw_points, and one by one determine whether
    // each point is above or below the line formed by the right and left points.
    // If it is above, the point is moved doubleo the upper_partition_points sequence. If it
    // is below, the point is moved doubleo the lower_partition_points sequence. So the output
    // of this routine is the left and right points, and the sorted points that are in the
    // upper and lower partitions.
    //
    void partition_points();
    //
    // Building the hull consists of two procedures: building the lower and
    // then the upper hull. The two procedures are nearly identical - the main
    // difference between the two is the test for convexity. When building the upper
    // hull, our rull is that the middle point must always be *above* the line formed
    // by its two closest neighbors. When building the lower hull, the rule is that point
    // must be *below* its two closest neighbors. We pass this information to the 
    // building routine as the last parameter, which is either -1 or 1.
    //
	//pu
#ifdef STAND_ALONE
    void build_hull( std::ofstream &f );
    
#else 
	void build_hull();
#endif
    //
    // This is the method that builds either the upper or the lower half convex
    // hull. It takes as its input a copy of the input array, which will be the
    // sorted list of points in one of the two halfs. It produces as output a list
    // of the points in the corresponding convex hull.
    //
    // The factor should be 1 for the lower hull, and -1 for the upper hull.
    //
#ifdef STAND_ALONE
    void build_half_hull( std::ostream &f, 
#else
			void build_half_hull(
#endif
                          std::vector< std::pair<double,double> > input,
                          std::vector< std::pair<double,double> > &output,
                          double factor );
    
    //
    // In this program we frequently want to look at three consecutive
    // points, p0, p1, and p2, and determine whether p2 has taken a turn
    // to the left or a turn to the right.
    //
    // We can do this by by translating the points so that p1 is at the origin,
    // then taking the cross product of p0 and p2. The result will be positive,
    // negative, or 0, meaning respectively that p2 has turned right, left, or
    // is on a straight line.
    //
    static double direction( std::pair<double,double> p0,
                          std::pair<double,double> p1,
							 std::pair<double,double> p2 );
						  void print_raw_points();
						  void log_raw_points( std::ostream &f );
						  void log_partitioned_points( std::ostream &f );
						  void print_hull();
						  void log_hull( std::ostream & f );
#ifndef GRAHAM_STAND_ALONE
						  void get_hull(matrixn& out);
#endif
						  void plot_raw_points( std::ostream &f );
						  void plot_partitioned_points( std::ostream &f );
						  void plot_hull( std::ostream &f, std::string text );
private :
    //
    // These values determine the range of numbers generated to 
    // provide the input data. The values are all passed in as part
    // of the constructor
    //
    size_t N;
    const std::pair<double,double> x_range;
    const std::pair<double,double> y_range;
    // The raw data points generated by the constructor
    std::vector< std::pair<double,double> > raw_points;
    //
    // These values are used to represent the partitioned set. A special
    // leftmost and rightmost value, and the sorted set of upper and lower
    // partitioned points that lie inside those two points.
    //
    std::pair<double,double> left;
    std::pair<double,double> right;
    std::vector< std::pair<double,double> > upper_partition_points;
    std::vector< std::pair<double,double> > lower_partition_points;
    //
    // After the convex hull is created, the lower hull and upper hull
    // are stored in these sorted sequences. There is a bit of duplication
    // between the two, because both sets include the leftmost and rightmost point.
    //
    std::vector< std::pair<double,double> > lower_hull;
    std::vector< std::pair<double,double> > upper_hull;
};
#endif
